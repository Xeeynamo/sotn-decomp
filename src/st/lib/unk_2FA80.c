// SPDX-License-Identifier: AGPL-3.0-or-later
#include "lib.h"

INCLUDE_ASM("st/lib/nonmatchings/unk_2FA80", func_us_801AFA80);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AB960);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AB988);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AB9A4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AB9C0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AB9D8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABA0C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABA30);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABA48);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABA60);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABA90);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABAA8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABAC4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABAE4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABB00);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABB20);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABB40);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABB74);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABBA4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABBD4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABBF0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABC0C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABC28);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABC38);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABC50);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABC90);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABCAC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABCCC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABCF8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABD18);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABD34);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABD58);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABD78);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABD98);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABDB4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABDD8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABDEC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABE1C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABE38);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABE58);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABE78);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABEA8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABED8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABEF8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABF24);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABF44);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABF58);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABF7C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABFA8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABFC8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABFDC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ABFF8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC02C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC054);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC08C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC0A0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC0B4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC0F4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC120);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC138);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC15C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC188);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC1B0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC1E4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC200);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC234);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC26C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC284);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC2A4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC2E0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC318);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC338);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC350);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC380);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC398);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC3C4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC3DC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC400);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC418);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC42C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC44C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC474);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC4A4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC4D8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC4F0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC50C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC528);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC548);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC57C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC5B0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC5DC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC600);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC618);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC630);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC64C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC66C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC684);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC6AC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC6D8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC6FC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC72C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC74C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC784);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC7A4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC7C4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC7E8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC818);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC834);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC868);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC8A0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC8B8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC8E0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC908);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC938);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC954);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC974);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC9A0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC9C4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801AC9E8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACA0C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACA24);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACA58);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACA8C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACAAC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACAC8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACAE4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACB04);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACB28);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACB48);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACB60);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACB7C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACBB4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACBCC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACBF4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACC2C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACC4C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACC74);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACC94);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACCC8);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACCF0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACD10);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACD3C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACD60);

INCLUDE_ASM("st/lib/nonmatchings/unk_2FA80", func_us_801AFE0C);

extern u8 D_us_801811FC[];
extern u8 D_us_80181204[];
extern u8 D_us_80181210[];
extern u8 D_us_8018121C[];
extern u8 D_us_80181234[];
extern u8 D_us_80181244[];
extern u8 D_us_801812C0[];
extern u8 D_us_801812C8[];
extern u8 D_us_801812D0[];
extern u8* D_us_801812D8[];

void EntityLibrarianChair(Entity* self) {
    Entity* newEnt;
    Entity* player = &PLAYER;
    Tilemap* tilemap = &g_Tilemap;

    if (self->step && (self->step < 11) && (g_SkipCutscene != 0) &&
        (g_IsCutsceneDone != 0)) {
        self->step = 11;
        self->animCurFrame = 2;
    }
    if (player->posX.i.hi < 0x38) {
        self->zPriority = 0xC0;
        if (g_Player.status & PLAYER_STATUS_TRANSFORM) {
            GetPlayerCollisionWith(self, 16, 12, 2);
            // If the chair is not in step 16, and the player is high enough,
            // and moving upward, trigger a hit.
        } else if (self->step < 16 &&
                   ((player->posY.i.hi + tilemap->scrollY.i.hi) < 201) &&
                   (FIX_TO_I(player->velocityY) < 0)) {
            SetStep(16);
            if (PLAYER.step == Player_HighJump) {
                g_Player.unk4A = 0x1C;
                if (PLAYER.step_s == 0) {
                    PLAYER.step_s = 1;
                    PLAYER.velocityY = FIX(-8);
                }
            }
            // Play chair jumping sound
            g_api.PlaySfx(SFX_QUICK_STUTTER_EXPLODE_B);
            self->ext.libraryChair.totalHits++;
            self->ext.libraryChair.consecutiveHits++;

            // At first hit, give Life Max Up.
            if (!(g_CastleFlags[LIBRARIAN_DROPS] & 1)) {
                newEnt = AllocEntity(&g_Entities[160], &g_Entities[192]);
                if (newEnt != NULL) {
                    CreateEntityFromCurrentEntity(E_PRIZE_DROP, newEnt);
                    newEnt->params = 23;
                    g_CastleFlags[LIBRARIAN_DROPS] |= 1;
                }
            }
            // Getting Axe Lord Armor requires hitting librarian 64 times.
            if (!(g_CastleFlags[LIBRARIAN_DROPS] & 2) &&
                (self->ext.libraryChair.totalHits >= 64)) {
                newEnt = AllocEntity(&g_Entities[160], &g_Entities[192]);
                if (newEnt != NULL) {
                    CreateEntityFromCurrentEntity(E_EQUIP_ITEM_DROP, newEnt);
                    newEnt->params = NUM_HAND_ITEMS + ITEM_AXE_LORD_ARMOR;
                    g_CastleFlags[LIBRARIAN_DROPS] |= 2;
                }
            }
            // Ring of Arcana requires 16 hits, without touching ground
            if (!(g_CastleFlags[LIBRARIAN_DROPS] & 4) &&
                (self->ext.libraryChair.consecutiveHits >= 16)) {
                newEnt = AllocEntity(&g_Entities[160], &g_Entities[192]);
                if (newEnt != NULL) {
                    CreateEntityFromCurrentEntity(E_EQUIP_ITEM_DROP, newEnt);
                    newEnt->params = NUM_HAND_ITEMS + ITEM_RING_OF_ARCANA;
                    g_CastleFlags[LIBRARIAN_DROPS] |= 4;
                }
            }
            // Dracula Tunic requires 24 hits, and inverted castle must be
            // unlocked.
            if (!(g_CastleFlags[LIBRARIAN_DROPS] & 8) &&
                (self->ext.libraryChair.consecutiveHits >= 24) &&
                (g_CastleFlags[INVERTED_CASTLE_UNLOCKED])) {
                newEnt = AllocEntity(&g_Entities[160], &g_Entities[192]);
                if (newEnt != NULL) {
                    CreateEntityFromCurrentEntity(E_EQUIP_ITEM_DROP, newEnt);
                    newEnt->params = NUM_HAND_ITEMS + ITEM_DRACULA_TUNIC;
                    g_CastleFlags[LIBRARIAN_DROPS] |= 8;
                }
            }
        }
    } else {
        self->zPriority = 0x80;
    }
    // If the player touches the ground, reset the frames airborne.
    if (g_Player.pl_vram_flag & 1) {
        self->ext.libraryChair.consecutiveHits = 0;
    }
    switch (self->step) {
    case 0:
        InitializeEntity(g_EInitCommon);
        self->zPriority = 0x80;
        self->animSet = ANIMSET_OVL(11);
        self->animCurFrame = 2;
        self->palette = 0x210;
        self->unk5A = 0x48;
        self->ext.libraryChair.debugAnimID = 0;
        self->ext.libraryChair.timer = 0x20;
        self->flags &= ~FLAG_DESTROY_IF_OUT_OF_CAMERA;
        if (g_PlayableCharacter != PLAYER_ALUCARD) {
            self->facingLeft = 1;
            self->posX.i.hi -= 8;
        }
        g_CutsceneFlags = 0;
        g_IsCutsceneDone = 0;
        g_SkipCutscene = 0;
        break;
    case 1:
        if (g_CutsceneFlags & 2) {
            if (--self->ext.libraryChair.timer) {
                SetStep(2);
            }
        } else {
            if (g_CutsceneFlags & 0x80) {
                SetStep(9);
            }
        }
        break;
    case 2:
        if (AnimateEntity(&D_us_801811FC, self) == 0) {
            SetStep(3);
        }
        break;
    case 3:
        AnimateEntity(&D_us_80181204, self);
        if (g_CutsceneFlags & 4) {
            SetStep(4);
        }
        break;
    case 4:
        AnimateEntity(&D_us_80181210, self);
        if (g_CutsceneFlags & 8) {
            SetStep(5);
        }
        break;
    case 5:
        AnimateEntity(&D_us_8018121C, self);
        if (g_CutsceneFlags & 0x10) {
            SetStep(6);
        }
        break;
    case 6:
        AnimateEntity(&D_us_80181234, self);
        if (g_CutsceneFlags & 0x20) {
            SetStep(7);
        }
        break;
    case 7:
        if (AnimateEntity(&D_us_80181244, self) == 0) {
            SetStep(11);
        }
        break;
    case 9:
        if (AnimateEntity(&D_us_801811FC, self) == 0) {
            SetStep(10);
        }
        break;
    case 10:
        if (AnimateEntity(&D_us_801812C0, self) == 0) {
            SetStep(11);
        }
        break;
    case 11:
        if (g_CutsceneFlags & 0x800) {
            SetStep(12);
            self->ext.libraryChair.timer = 0x30;
        }
        if (g_CutsceneFlags & 0x1000) {
            SetStep(13);
        }
        break;
    case 12:
        AnimateEntity(&D_us_801812C8, self);
        if (!--self->ext.libraryChair.timer) {
            g_CutsceneFlags &= ~0x800;
            self->animCurFrame = 2;
            SetStep(11);
        }
        if (g_CutsceneFlags & 0x1000) {
            self->animCurFrame = 2;
            SetStep(13);
        }
        break;
    case 13:
        break;
    case 16:
        AnimateEntity(&D_us_801812D0, self);
        if (g_Player.status & PLAYER_STATUS_TRANSFORM) {
            self->velocityY += FIX(3.0 / 8);
            if (self->velocityY > FIX(7)) {
                self->velocityY = FIX(7);
            }
            MoveEntity();
            GetPlayerCollisionWith(self, 16, 12, 0x12);
        } else {
            if (PLAYER.step == Player_HighJump && PLAYER.step_s == 0) {
                PLAYER.step_s = 1;
                PLAYER.velocityY = FIX(-8);
            }
            self->posY.i.hi = player->posY.i.hi - 0x1C;
            self->velocityY = player->velocityY;
        }
        if ((self->posY.i.hi + tilemap->scrollY.i.hi) >= 172) {
            self->posY.i.hi = 172 - tilemap->scrollY.i.hi;
            self->animCurFrame = 2;
            SetStep(1);
        }
        break;
    case 255:
        if (g_pads[0].tapped & PAD_UP) {
            if (self->ext.libraryChair.debugAnimID) {
                self->ext.libraryChair.debugAnimID--;
                self->animFrameIdx = 0;
                self->animFrameDuration = 0;
            }
        } else if (g_pads[0].tapped & PAD_DOWN) {
            if (self->ext.libraryChair.debugAnimID != 0x10) {
                self->ext.libraryChair.debugAnimID++;
                self->animFrameIdx = 0;
                self->animFrameDuration = 0;
            }
        }
        AnimateEntity(D_us_801812D8[self->ext.libraryChair.debugAnimID], self);
        break;
    }
}

void* func_us_801B0C40(u8* pix, u8* str, s32 x, s32 y, s32 size) {
    const u16 MINSCODE = 0x8140;
    const u16 RIGHT_DOUBLE_QUOTATION_MARK = 0x8168;

    const int FontWidth = 12;
    const int FontHeight = 16;
    const int FontStride = FontWidth / 2;

    s32 letterWidth;
    s32 i, j;
    s32 pos;
    s32 s_8;
    s32 s_6;
    u16 ch;
    u8* ptr;
    u8* chPix;
    u8 sp3f;

    s_6 = 0;
    ptr = pix;
    for (i = 0; i < (size * FontHeight) * 2; i++) {
        *ptr++ = 0;
    }
    while (true) {
        pos = 0;
        while (*str >= 8) {
            s_8 = 0;
#if VERSION_PSP
            ch = g_api.func_ptr_91CF870((char*)str, &sp3f);
#else
            ch = *str;
#endif
            str++;
            if (ch == '@') {
                break;
            }
            if (ch >= 'a' && ch <= 'z') {
                ch = ch + 0x8220;
            } else if (ch >= 'A' && ch <= 'Z') {
                ch = ch + 0x821F;
            } else if (ch == ' ') {
                ch = MINSCODE;
                s_8 = 2;
            } else {
#if VERSION_PSP
                if (sp3f > 1) {
                    str += sp3f - 1;
                }
            }
#else
                ch = *str++ | (ch << 8);
                if (ch == MINSCODE) {
                    s_8 = 2;
                }
            }
            if (ch == RIGHT_DOUBLE_QUOTATION_MARK) {
                str += 2;
            }
#endif
            chPix = (u8*)g_api.func_80106A28(ch, 1);
            while (true) {
                if (ch == MINSCODE) {
                    break;
                }
                for (i = 0; i < FontHeight; i++) {
                    if (chPix[i * FontStride]) {
                        break;
                    }
                }
                if (i != 16) {
                    break;
                }
                for (i = 0; i < FontHeight; i++) {
                    ptr = &chPix[i * FontStride];
                    for (j = 0; j < 5; j++) {
                        *(ptr + 0) = *(ptr + 1);
                        ptr += 1;
                    }
                    *ptr = 0;
                }
            }

            for (i = 0, letterWidth = 0; i < FontHeight; i++) {
                for (j = 0; j < FontStride; j++) {
                    if (chPix[i * FontStride + j] && (letterWidth < j)) {
                        letterWidth = j;
                    }
                }
            }
            for (i = 0; i < FontHeight; i++) {
                if (chPix[letterWidth + i * FontStride] & 0xF0) {
                    break;
                }
            }

            if (i != 16) {
                letterWidth++;
            }
            if (letterWidth < 6) {
                letterWidth++;
            }
            for (i = 0; i < FontHeight; i++) {
                ptr = &pix[pos + (i + (s_6 * FontHeight)) * size];
                *ptr++ = *chPix++;
                *ptr++ = *chPix++;
                *ptr++ = *chPix++;
                *ptr++ = *chPix++;
                *ptr++ = *chPix++;
                *ptr++ = *chPix++;
            }
            pos += letterWidth + s_8;
            if (pos >= size - 5) {
                break;
            }
        }
        LoadTPage(
            (u_long*)&pix[s_6 * FontHeight * size], 0, 0, x, y, size * 2, 0x10);
        if (!*str) {
            break;
        }
        s_6++;
        y += 16;
        if (*str < 8) {
            str++;
        }
    }
    return &pix[(size << 4) << 1];
}

void func_us_801B0FBC(u8* ptr, u16 x, u16 y) {
    RECT rect;
    u8 pos;

loop:
    pos = *ptr++;
    if (pos) {
        if (pos == 0x20) {
            x++;
            goto loop;
#ifdef VERSION_PSP
        } else if (pos == 0xCC) {
            pos = 0xBB;
#endif
        }
        rect.x = ((pos & 0xF) << 1) + 0x380;
        rect.y = ((pos & 0xF0) >> 1) + 0xF0;
        rect.w = 2;
        rect.h = 8;
        MoveImage(&rect, x, y);
        x += 2;
        goto loop;
    }
}

INCLUDE_ASM("st/lib/nonmatchings/unk_2FA80", func_us_801B1064);

void func_us_801B11A0(s16 x, s16 y, u16 w, u16 h) {
    RECT rect;

    rect.x = x / 4;
    rect.y = y;
    rect.w = w / 4 + 1;
    rect.h = h + 1;
    ClearImage(&rect, 0, 0, 0);
}

INCLUDE_ASM("st/lib/nonmatchings/unk_2FA80", func_us_801B1200);

INCLUDE_ASM("st/lib/nonmatchings/unk_2FA80", func_us_801B12D0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACDE0);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACDEC);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACDF4);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACE00);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACE0C);

INCLUDE_RODATA("st/lib/nonmatchings/unk_2FA80", D_us_801ACE18);

extern u8* D_us_80181310[];
extern u8* D_us_80181340[];
extern u8 D_us_80183F64;

extern s32 D_psp_08B42050;
extern s32 D_psp_08B42054;
extern u8* D_psp_092A54E0;
extern s32 D_psp_092A5500;
extern s32 D_psp_092A5538;
extern s32 D_psp_092A5608;
extern s32 D_psp_092A5610;
extern s32 D_psp_092A5628;
extern s32 D_psp_092A5630;
extern s32 D_psp_092A5638;
extern s32 D_psp_092A5640;
extern u8** D_psp_092A5FC0[];

void func_us_801B15C0(Entity* self) {
    Entity* tempEntity;
    Primitive* otherPrim;
    Primitive* prim;
    s32 primIndex;
    s16 tempVar;
    s32 i;
    u16 tempVar2;
    u8* ptr;
    s16 pad;

    switch (self->step) {
    case 0:
        InitializeEntity(g_EInitCommon);
        primIndex = g_api.AllocPrimitives(PRIM_G4, 7);
        if (primIndex != -1) {
            self->flags |= FLAG_HAS_PRIMS;
            self->primIndex = primIndex;
            if (g_IsTimeAttackUnlocked) {
#ifdef VERSION_PSP
                self->params = 3;
#else
                self->params = 2;
#endif
            } else {
                self->params = 1;
            }
            ptr = D_us_80181340[self->params];
            self->ext.et_801B15C0.unk84 = *ptr++;
            for (i = 0; i < self->ext.et_801B15C0.unk84; i++) {
                self->ext.et_801B15C0.unk88[i] = *ptr++;
            }
            self->ext.et_801B15C0.unk86 = (self->ext.et_801B15C0.unk84 * 8) + 4;
            i = 0;
            prim = &g_PrimBuf[primIndex];
            for (; prim != NULL; i++) {
                prim->x0 = prim->x1 = prim->x2 = prim->x3 = 0xC0;
                prim->y0 = prim->y1 = prim->y2 = prim->y3 = 0x60;
                if (i == 0) {
                    PRED(prim) = 0x40;
                    PGRN(prim) = 0x10;
                    PBLU(prim) = 0x10;
#ifdef VERSION_PSP
                    prim->x0 = prim->x2 = 0x95;
                    prim->x1 = prim->x3 = 0xEC;
#else
                    prim->x0 = prim->x2 = 0x98;
                    prim->x1 = prim->x3 = 0xE8;
#endif
                    prim->priority = 0xC0;
                    prim->drawMode = DRAW_HIDE;
                } else if (i < 5) {
                    prim->type = PRIM_LINE_G2;
                    prim->r0 = prim->r1 = 0x80;
                    prim->g0 = prim->g1 = 0x80;
                    prim->b0 = prim->b1 = 0x80;
                    prim->priority = 0xC1;
                    prim->drawMode = DRAW_HIDE;
                } else if (i == 5) {
                    PRED(prim) = 0;
                    PGRN(prim) = 0;
                    PBLU(prim) = 0x40;
                    prim->priority = 0xBF;
                    prim->drawMode = DRAW_TPAGE | DRAW_COLORS | DRAW_TRANSP;
                } else if (i == 6) {
                    prim->type = PRIM_GT4;
                    prim->tpage = 0x10;
                    prim->clut = 0x1A1;
                    prim->u0 = prim->u2 = 0;
#ifdef VERSION_PSP
                    prim->u1 = prim->u3 = 0x58;
#else
                    prim->u1 = prim->u3 = 0x54;
#endif
                    prim->v0 = prim->v1 = 0;
                    prim->v2 = prim->v3 = self->ext.et_801B15C0.unk86 * 2;
                    prim->priority = 0xC1;
                    prim->drawMode = DRAW_HIDE;
                }
                prim = prim->next;
            }
#ifdef VERSION_PSP
            func_us_801B11A0(0, 0x100, 0x58, self->ext.et_801B15C0.unk86 * 2);
#else
            func_us_801B11A0(0, 0x100, 0x54, self->ext.et_801B15C0.unk86 * 2);
#endif
            return;
        }
        self->step = 0;
        break;

    case 1:
        for (i = 0; i < self->ext.et_801B15C0.unk84; i++) {
#ifdef VERSION_PSP
            ptr = *(*D_psp_092A5FC0 + self->ext.et_801B15C0.unk88[i]);
#else
            ptr = D_us_80181310[self->ext.et_801B15C0.unk88[i]];
#endif
            tempVar = *ptr++;
            func_us_801B0FBC(ptr, tempVar, 0x108 + i * 16);
        }
        self->step++;
        break;

    case 2:
        if (g_CutsceneFlags & 0x200) {
            SetStep(3);
            self->ext.et_801B15C0.unk7C = 0;
            self->ext.et_801B15C0.unk7E = 0;
            self->ext.et_801B15C0.unk80 = 0;
            g_Settings.D_8003CB04 |= 8;
        }
        break;

    case 3:
        self->ext.et_801B15C0.unk7C++;
        self->ext.et_801B15C0.unk7E += 0x40;
        prim = &g_PrimBuf[self->primIndex];
        prim = prim->next;
        otherPrim = prim;
        for (i = 0; i < 4; i++) {
            prim = prim->next;
        }
        i = 0;
        tempVar2 = self->ext.et_801B15C0.unk86;
        for (; prim != NULL; i++) {
#ifdef VERSION_PSP
            tempVar = (self->ext.et_801B15C0.unk7C * 0x2C) / 0x20;
            if (tempVar > 0x2C) {
                tempVar = 0x2C;
            }
#else
            tempVar = (self->ext.et_801B15C0.unk7C * 0x2A) / 0x20;
            if (tempVar > 0x2A) {
                tempVar = 0x2A;
            }
#endif
            prim->x1 = tempVar + 0xC0;
            prim->x2 = 0xC0 - tempVar;
            tempVar = self->ext.et_801B15C0.unk7C * tempVar2 / 0x20;
            if (tempVar > tempVar2) {
                tempVar = tempVar2;
            }
            prim->y1 = 0x60 - tempVar;
            prim->y2 = tempVar + 0x60;
#ifdef VERSION_PSP
            tempVar = ((s16)self->ext.et_801B15C0.unk7C * 0x2C) / 0x40;
#else
            tempVar = ((s16)self->ext.et_801B15C0.unk7C * 0x2A) / 0x40;
#endif
            tempVar = (rcos(self->ext.et_801B15C0.unk7E) * tempVar) / 0x1000;
            prim->x0 = 0xC0 - tempVar;
            prim->x3 = tempVar + 0xC0;
            tempVar = ((s16)self->ext.et_801B15C0.unk7C * tempVar2) / 0x40;
            tempVar = (rcos(self->ext.et_801B15C0.unk7E) * tempVar) / 0x1000;
            prim->y0 = 0x60 - tempVar;
            prim->y3 = tempVar + 0x60;
            if (self->ext.et_801B15C0.unk7E >= 0x400 &&
                self->ext.et_801B15C0.unk7E < 0xC00) {
                if (i) {
                    prim->priority = 0xBF;
                    prim->drawMode = DRAW_DEFAULT;
                } else {
                    prim->priority = 0xC1;
                }
            } else {
                if (i) {
                    prim->priority = 0xC1;
                } else {
                    prim->priority = 0xBF;
                }
            }
            if (i == 0) {
                func_us_801B1200(otherPrim, prim);
            }
            prim = prim->next;
        }
        if (self->ext.et_801B15C0.unk7C == 0x40) {
            SetStep(4);
        }
        break;

    case 4:
        pad = g_pads[0].repeat;
        if (pad & PAD_DOWN) {
            if (self->ext.et_801B15C0.unk80 < self->ext.et_801B15C0.unk84 - 1) {
                g_api.PlaySfx(SFX_UI_MOVE);
                self->ext.et_801B15C0.unk80++;
            }
        } else if (pad & PAD_UP) {
            if (self->ext.et_801B15C0.unk80 > 0) {
                g_api.PlaySfx(SFX_UI_MOVE);
                self->ext.et_801B15C0.unk80--;
            }
        }
        pad = g_pads[0].tapped;
#ifdef VERSION_PSP
        if (pad & D_psp_08B42050) {
#else
        if (pad & PAD_CROSS) {
#endif
            switch (self->ext.et_801B15C0.unk88[self->ext.et_801B15C0.unk80]) {
            case 0:
                g_CutsceneFlags |= 0x400;
                tempEntity = self + 1;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5640, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_27, tempEntity);
#endif
                tempEntity++;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5638, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_28, tempEntity);
#endif
                tempEntity++;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5630, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_29, tempEntity);
#endif
                tempEntity++;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5628, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_2A, tempEntity);
#endif
                SetStep(5);
                g_api.PlaySfx(SFX_UI_CONFIRM);
                break;

            case 1:
                g_CutsceneFlags |= 0x400;
                tempEntity = self + 1;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5610, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_2D, tempEntity);
#endif
                SetStep(5);
                g_api.PlaySfx(SFX_UI_CONFIRM);
                break;

            case 2:
                g_CutsceneFlags |= 0x400;
                tempEntity = self + 1;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5608, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_2E, tempEntity);
#endif
                SetStep(5);
                g_api.PlaySfx(SFX_UI_CONFIRM);
                break;

            case 3:
                g_CutsceneFlags |= 0x400;
                tempEntity = self + 1;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5538, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_48, tempEntity);
#endif
                SetStep(5);
                g_api.PlaySfx(SFX_UI_CONFIRM);
                break;

            case 4:
                SetStep(6);
                g_api.PlaySfx(SFX_UI_CONFIRM);
                break;

            case 5:
                g_CutsceneFlags |= 0x400;
                tempEntity = self + 1;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5640, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_27, tempEntity);
#endif
                tempEntity->params = 1;
                tempEntity++;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5638, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_28, tempEntity);
#endif
                tempEntity++;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5630, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_29, tempEntity);
#endif
                tempEntity++;
#ifdef VERSION_PSP
                CreateEntityFromCurrentEntity(D_psp_092A5628, tempEntity);
#else
                CreateEntityFromCurrentEntity(E_ID_2A, tempEntity);
#endif
                SetStep(5);
                g_api.PlaySfx(SFX_UI_CONFIRM);
                break;

#ifdef VERSION_PSP
            case 6:
                g_CutsceneFlags |= 0x400;
                tempEntity = self + 1;
                CreateEntityFromCurrentEntity(D_psp_092A5500, tempEntity);
                SetStep(5);
                g_api.PlaySfx(SFX_UI_CONFIRM);
                break;
#endif
            }
#ifdef VERSION_PSP
        } else if (g_pads[0].tapped & D_psp_08B42054) {
#else
        } else if (g_pads[0].tapped & PAD_TRIANGLE) {
#endif
            SetStep(6);
            g_api.PlaySfx(SFX_UI_CONFIRM);
        }
        prim = &g_PrimBuf[self->primIndex];
        prim->y0 = prim->y1 = (0x64 - self->ext.et_801B15C0.unk86) +
                              self->ext.et_801B15C0.unk80 * 0x10;
        prim->y2 = prim->y3 = prim->y0 + 0x10;
        prim->drawMode = DRAW_COLORS;
        break;

    case 5:
        switch (self->step_s) {
        case 0:
            if (g_api.func_80131F68()) {
                g_api.PlaySfx(SET_STOP_MUSIC);
                self->step_s++;
            } else {
                self->step_s++;
            }
            break;

        case 1:
            if (!g_api.func_80131F68()) {
                if (self->ext.et_801B15C0.unk80 != 4) {
                    g_api.PlaySfx(NA_VO_AL_INTERESTED);
                }
                if (!self->ext.et_801B15C0.unk80 ||
                    self->ext.et_801B15C0.unk80 == 1) {
                    self->ext.et_801B15C0.unk82 = 1;
                } else {
                    self->ext.et_801B15C0.unk82 = 0;
                }
#ifndef VERSION_PSP
                if (self->ext.et_801B15C0.unk80 < 3) {
                    self->ext.et_801B15C0.unk82 |= 0x10;
                }
#endif
                SetStep(9);
            }
            break;
        }
        break;

    case 6:
        switch (self->step_s) {
        case 0:
#ifdef VERSION_PSP
            *D_psp_092A54E0 = 0;
#else
            D_us_80183F64 = 0;
#endif
            if (g_api.func_80131F68()) {
                g_api.PlaySfx(SET_STOP_MUSIC);
                self->step_s++;
            } else {
                self->step_s++;
            }
            break;

        case 1:
            if (!g_api.func_80131F68()) {
                g_api.PlaySfx(NA_VO_ML_FAREWELL);
                self->ext.et_801B15C0.unk7C = 0x20;
                self->step_s++;
            }
            break;

        case 2:
            if (!--self->ext.et_801B15C0.unk7C) {
                SetStep(7);
                g_CutsceneFlags |= 0x100;
                g_PauseAllowed = true;
                g_unkGraphicsStruct.pauseEnemies = 0;
            }
            break;
        }
        break;

    case 7:
        prim = &g_PrimBuf[self->primIndex];
        prim->drawMode = DRAW_HIDE;
        self->ext.et_801B15C0.unk7E = 0;
        self->ext.et_801B15C0.unk7C = 0x40;
        self->step++;
        break;

    case 8:
        self->ext.et_801B15C0.unk7C--;
        self->ext.et_801B15C0.unk7E += 0x40;
        prim = &g_PrimBuf[self->primIndex];
        prim = prim->next;
        otherPrim = prim;
        for (i = 0; i < 4; i++) {
            prim = prim->next;
        }
        i = 0;
        tempVar2 = self->ext.et_801B15C0.unk86;
        for (; prim != NULL; i++) {
#ifdef VERSION_PSP
            tempVar = (self->ext.et_801B15C0.unk7C * 0x2C) / 0x20;
            if (tempVar > 0x2C) {
                tempVar = 0x2C;
            }
#else
            tempVar = (self->ext.et_801B15C0.unk7C * 0x2A) / 0x20;
            if (tempVar > 0x2A) {
                tempVar = 0x2A;
            }
#endif
            prim->x3 = tempVar + 0xC0;
            prim->x0 = 0xC0 - tempVar;
            tempVar = (self->ext.et_801B15C0.unk7C * tempVar2) / 0x20;
            if (tempVar > tempVar2) {
                tempVar = tempVar2;
            }
            prim->y0 = 0x60 - tempVar;
            prim->y3 = tempVar + 0x60;
#ifdef VERSION_PSP
            tempVar = ((s16)self->ext.et_801B15C0.unk7C * 0x2C) / 0x40;
#else
            tempVar = ((s16)self->ext.et_801B15C0.unk7C * 0x2A) / 0x40;
#endif
            tempVar = rcos(self->ext.et_801B15C0.unk7E) * tempVar / 0x1000;
            prim->x2 = 0xC0 - tempVar;
            prim->x1 = tempVar + 0xC0;
            tempVar = ((s16)self->ext.et_801B15C0.unk7C * tempVar2) / 0x40;
            tempVar = rcos(self->ext.et_801B15C0.unk7E) * tempVar / 0x1000;
            prim->y1 = 0x60 - tempVar;
            prim->y2 = tempVar + 0x60;
            if (self->ext.et_801B15C0.unk7E >= 0x400 &&
                self->ext.et_801B15C0.unk7E < 0xC00) {
                if (i) {
                    prim->priority = 0xBF;
                } else {
                    prim->priority = 0xC1;
                }
            } else if (i) {
                prim->priority = 0xC1;
                if (self->ext.et_801B15C0.unk7E >= 0xC00) {
                    prim->drawMode = DRAW_HIDE;
                }
            } else {
                prim->priority = 0xBF;
            }
            if (i == 0) {
                if (self->ext.et_801B15C0.unk7C) {
                    func_us_801B1200(otherPrim, prim);
                } else {
                    otherPrim->drawMode = DRAW_HIDE;
                    otherPrim = otherPrim->next;
                    otherPrim->drawMode = DRAW_HIDE;
                    otherPrim = otherPrim->next;
                    otherPrim->drawMode = DRAW_HIDE;
                    otherPrim = otherPrim->next;
                    otherPrim->drawMode = DRAW_HIDE;
                }
            }
            prim = prim->next;
        }
        if (!self->ext.et_801B15C0.unk7C) {
            g_CutsceneFlags &= ~0x200;
            SetStep(2);
        }
        break;

    case 9:
        prim = &g_PrimBuf[self->primIndex];
        prim->drawMode = DRAW_HIDE;
        self->ext.et_801B15C0.unk7C = 0;
        self->step++;
        break;

    case 10:
        self->ext.et_801B15C0.unk7C++;
        func_us_801B12D0(self, self->ext.et_801B15C0.unk82);
        if (self->ext.et_801B15C0.unk7C >= 0x18) {
            g_CutsceneFlags &= ~0x200;
            SetStep(11);
        }
        break;

    case 11:
        if (g_CutsceneFlags & 0x200) {
            SetStep(12);
            self->ext.et_801B15C0.unk7C = 0x18;
        }
        break;

    case 12:
        self->ext.et_801B15C0.unk7C--;
        func_us_801B12D0(self, self->ext.et_801B15C0.unk82);
        if (!self->ext.et_801B15C0.unk7C) {
            SetStep(4);
        }
        break;
    }
}
