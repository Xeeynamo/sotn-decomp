// SPDX-License-Identifier: AGPL-3.0-or-later
#include "nz0.h"
#include "sfx.h"

// This file holds functions to handle the Slogra and Gaibon fight.
// Slogra and Gaibon themselves are in individual files.
s32 g_BossFlag = 0x00000000;
static s16 D_80181014[][3] = {
    {0xFFF8, 0x0068, 0}, {0xFFF8, 0x0078, 0}, {0xFFF8, 0x0088, 0},
    {0xFFF8, 0x0098, 0}, {0x0408, 0x0068, 1}, {0x0408, 0x0078, 1},
    {0x0408, 0x0088, 1}, {0x0408, 0x0098, 1}, {0x0408, 0x0168, 1},
    {0x0408, 0x0178, 1}, {0x0408, 0x0188, 1}, {0x0408, 0x0198, 1}};
s16 D_8018105C[] = {0x0000, 0x0020, 0x0000, 0x0004,
                    0x0010, 0xFFFC, 0xFFE0, 0x0000};
s16 D_8018106C[] = {0x0000, 0x0020, 0x0010, 0x0000};
u8 D_80181074[] = {0x09, 0x01, 0x08, 0x02, 0x0C, 0x03,
                   0x0A, 0x02, 0x00, 0x00, 0x00, 0x00};
u8 D_80181080[] = {0x07, 0x01, 0x07, 0x04, 0x07, 0x05,
                   0x11, 0x01, 0x00, 0x00, 0x00, 0x00}; // Taunt
u8 D_8018108C[] = {0x08, 0x01, 0x04, 0x1F, 0x0A, 0x20, 0x04, 0x21,
                   0x04, 0x22, 0x04, 0x06, 0xFF, 0x00}; // Firing projectiles
u8 D_8018109C[] = {0x04, 0x06, 0x03, 0x07, 0x02, 0x09,
                   0x04, 0x08, 0x20, 0x06, 0xFF, 0x00};
u8 D_801810A8[] = {0x01, 0x06, 0x06, 0x20, 0x06, 0x1F, 0x35, 0x01, 0xFF, 0x00};
u8 D_801810B4[] = {0x07, 0x01, 0x05, 0x0A, 0x16, 0x0B, 0x02, 0x0C, 0x02,
                   0x0D, 0x02, 0x0E, 0x02, 0x0F, 0x41, 0x0E, 0xFF, 0x00};
static u8 _unused_anim[] = {
    0x18, 0x0E, 0x06, 0x0D, 0x05, 0x1F, 0x22, 0x01, 0xFF, 0x00};
u8 D_801810D4[] = {0x03, 0x10, 0x03, 0x11, 0x01, 0x12, 0x01, 0x13, 0x01,
                   0x12, 0x01, 0x13, 0x01, 0x12, 0x18, 0x13, 0xFF, 0x00};
u8 D_801810E8[] = {0x03, 0x10, 0x03, 0x11, 0x03, 0x12, 0x01, 0x15, 0x01, 0x14,
                   0x01, 0x15, 0x01, 0x14, 0x01, 0x15, 0x28, 0x14, 0xFF, 0x00};
u8 D_801810FC[] = {0x09, 0x16, 0x08, 0x17, 0x0C, 0x18,
                   0x0A, 0x17, 0x00, 0x00, 0x00, 0x00};
u8 D_80181108[] = {0x07, 0x16, 0x07, 0x19, 0x07, 0x1A,
                   0x11, 0x16, 0x00, 0x00, 0x00, 0x00};
u8 D_80181114[] = {0x03, 0x1B, 0x03, 0x1C, 0x01, 0x15, 0x01, 0x14, 0x01,
                   0x15, 0x01, 0x14, 0x01, 0x15, 0x18, 0x14, 0xFF, 0x00};
u8 D_80181128[] = {0x05, 0x19, 0x05, 0x1A, 0x05, 0x1B, 0x05, 0x1C,
                   0x07, 0x14, 0x0E, 0x15, 0x05, 0x1B, 0x02, 0x1E,
                   0x01, 0x1D, 0x01, 0x1E, 0x32, 0x1D, 0xFF, 0x00};
u8 D_80181140[] = {0x02, 0x15, 0x02, 0x1B, 0x02, 0x1E, 0x01,
                   0x1D, 0x01, 0x1E, 0x02, 0x1D, 0xFF, 0x00};
u8 D_80181150[] = {0x02, 0x15, 0x03, 0x14, 0x00, 0x00, 0x00, 0x00};
u8 D_80181158[] = {0x03, 0x24, 0x02, 0x25, 0xFF, 0x00};
u8 D_80181160[] = {0x02, 0x26, 0x02, 0x27, 0x02, 0x28, 0x02,
                   0x29, 0x02, 0x2A, 0x02, 0x2B, 0xFF, 0x00};
u8 D_80181170[] = {0x01, 0x26, 0x01, 0x27, 0x00, 0x00, 0x00, 0x00};
u8 D_80181178[][4] = {
    {0x00, 0x00, 0x00, 0x00}, {0xF8, 0x02, 0x13, 0x1B},
    {0xF4, 0x06, 0x13, 0x18}, {0xF5, 0x06, 0x13, 0x18},
    {0xF9, 0x02, 0x13, 0x1B}, {0x00, 0x02, 0x13, 0x1B},
    {0xAE, 0xA0, 0x00, 0x00}, {0xE5, 0x0D, 0x20, 0x0B},
    {0xF7, 0x02, 0x13, 0x1B}, {0xAB, 0x9F, 0x00, 0x00},
    {0xFC, 0x12, 0x08, 0x20}, {0x00, 0x00, 0x07, 0x04},
    {0x01, 0x01, 0x04, 0x0B}, {0x02, 0x01, 0x07, 0x07},
    {0x02, 0x01, 0x09, 0x04}, {0x03, 0x01, 0x07, 0x05}};
u8 D_801811B8[] = {0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x02, 0x02,
                   0x04, 0x05, 0x01, 0x01, 0x02, 0x02, 0x05, 0x05, 0x05, 0x05,
                   0x05, 0x05, 0x01, 0x01, 0x01, 0x04, 0x04, 0x01, 0x01, 0x07,
                   0x07, 0x08, 0x08, 0x08, 0x08, 0x09, 0x01, 0x01, 0x00, 0x00};
s8 D_801811E0[][4] = {
    {0x00, 0x00, 0x00, 0x00}, {0xDC, 0x0C, 0x08, 0x05},
    {0xDC, 0x0B, 0x08, 0x05}, {0xCD, 0xFB, 0x13, 0x06},
    {0xCF, 0xFB, 0x13, 0x06}, {0xDF, 0x0C, 0x07, 0x04},
    {0xE5, 0x08, 0x07, 0x04}, {0xDE, 0x0D, 0x07, 0x04},
    {0xD8, 0x10, 0x0A, 0x04}, {0xCC, 0xFB, 0x13, 0x06},
    {0xAE, 0xA0, 0x00, 0x00}, {0xDC, 0x0E, 0x07, 0x04},
    {0xDC, 0x10, 0x07, 0x04}, {0xFC, 0x12, 0x04, 0x20}};
u8 D_80181218[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x03, 0x03,
                   0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 0x0A,
                   0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
                   0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x0D, 0x00, 0x00};
u16 D_80181240[] = {0x0000, 0x001C, 0x0000, 0x0004,
                    0x0004, 0xFFFC, 0xFFF8, 0x0000};
u8 D_80181250[] = {0x06, 0x01, 0x03, 0x09, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04,
                   0x04, 0x0A, 0x05, 0x03, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00};
u8 D_80181264[] = {
    0x02, 0x01, 0x01, 0x09, 0x01, 0x02, 0x01, 0x03, 0x01, 0x04, 0x01,
    0x0A, 0x02, 0x03, 0x02, 0x02, 0x04, 0x01, 0x02, 0x09, 0x01, 0x02,
    0x01, 0x03, 0x02, 0x04, 0x02, 0x0A, 0x03, 0x03, 0x03, 0x02, 0x05,
    0x01, 0x02, 0x09, 0x02, 0x02, 0x02, 0x03, 0x02, 0x04, 0x03, 0x0A,
    0x04, 0x03, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00};
u8 D_80181298[] = {0x06, 0x05, 0x03, 0x0B, 0x02, 0x06, 0x02, 0x07, 0x03, 0x08,
                   0x04, 0x0C, 0x05, 0x07, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00};
u8 D_801812AC[] = {0x06, 0x20, 0x03, 0x21, 0x02, 0x22, 0x02, 0x23, 0x03, 0x24,
                   0x04, 0x25, 0x05, 0x23, 0x05, 0x22, 0x00, 0x00, 0x00, 0x00};
u8 D_801812C0[] = {0x05, 0x0D, 0x05, 0x0E, 0x04, 0x0F,
                   0x08, 0x0E, 0xFF, 0x00, 0x00, 0x00};
u8 D_801812CC[] = {0x03, 0x0E, 0x03, 0x10, 0x03, 0x11, 0x04, 0x12,
                   0x04, 0x13, 0x22, 0x12, 0xFF, 0x00, 0x00, 0x00};
u8 D_801812DC[] = {0x04, 0x03, 0x01, 0x16, 0x01, 0x15, 0x01, 0x16, 0x04, 0x15,
                   0x04, 0x17, 0x04, 0x14, 0x01, 0x18, 0xFF, 0x00, 0x00, 0x00};
u8 D_801812F0[] = {0x05, 0x0D, 0x05, 0x12, 0x05, 0x19,
                   0x04, 0x1A, 0x29, 0x19, 0xFF, 0x00};
u8 D_801812FC[] = {0x02, 0x19, 0x02, 0x1B, 0x00, 0x00, 0x00, 0x00};
u8 D_80181304[] = {0x10, 0x19, 0x05, 0x1C, 0x06, 0x1D,
                   0x20, 0x1E, 0xFF, 0x00, 0x00, 0x00};
s8 D_80181310[] = {
    0x00, 0x00, 0x00, 0x00, 0xFD, 0xFC, 0x0F, 0x1B, 0xFD, 0xFD, 0x0F, 0x19,
    0xFD, 0xFF, 0x0F, 0x18, 0xFD, 0xFF, 0x0F, 0x17, 0xFC, 0x04, 0x0F, 0x17,
    0xFD, 0xFD, 0x10, 0x15, 0xFD, 0xFD, 0x10, 0x14, 0xFB, 0x04, 0x11, 0x17,
    0xC5, 0xB6, 0x00, 0x00, 0xFB, 0xF9, 0x0F, 0x14, 0xFB, 0xFB, 0x0F, 0x12};
u8 D_80181340[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x04,
    0x01, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06,
    0x06, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x0A,
    0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0A, 0x0B, 0x0B, 0x00, 0x00, 0x00};
u8 D_8018136C[] = {0x02, 0x03, 0x02, 0x04, 0x02, 0x05,
                   0x02, 0x04, 0x00, 0x00, 0x00, 0x00};
u8 D_80181378[] = {0x02, 0x0D, 0x02, 0x0E, 0x02, 0x0F, 0x02, 0x10,
                   0x02, 0x0F, 0x02, 0x0E, 0x00, 0x00, 0x00, 0x00};
u8 D_80181388[] = {0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x04, 0x01, 0x05,
                   0x01, 0x06, 0x01, 0x07, 0x01, 0x08, 0x01, 0x09, 0x01, 0x0A,
                   0x01, 0x0B, 0x01, 0x0C, 0x01, 0x0D, 0xFF, 0x00};

void EntityBossFightManager(Entity* self) {
    Entity* newEnt;
    s32 i;
    s16* temp_s1;
    s32 xPos;
    s32 newEntY;
    bool bosses_defeated;

    FntPrint("boss_flag %x\n", g_BossFlag);
    FntPrint("boss_step %x\n", self->step);
    switch (self->step) {
    case 0:
        bosses_defeated = g_api.TimeAttackController(
            TIMEATTACK_EVENT_SLOGRA_GAIBON_DEFEAT, TIMEATTACK_GET_RECORD);
        if (bosses_defeated) {
            DestroyEntity(self);
            return;
        }
        InitializeEntity(g_EInitInteractable);
        g_BossFlag = 0;
        newEnt = self + 1;
        temp_s1 = D_80181014;
        for (i = 0; i < LEN(D_80181014); i++, newEnt++, temp_s1 += 3) {
            CreateEntityFromCurrentEntity(E_BOSS_ROOM_BLOCK, newEnt);
            newEnt->params = temp_s1[2];
            newEnt->posX.i.hi = temp_s1[0] - g_Tilemap.scrollX.i.hi;
            newEnt->posY.i.hi = temp_s1[1] - g_Tilemap.scrollY.i.hi;
        }
        // This spawns Slogra and Gaibon! Note that they always spawn at slot
        // 80 and 88, which allows the SLOGRA and GAIBON macros (self[8]) to
        // work.
        newEnt = &g_Entities[80];
        CreateEntityFromCurrentEntity(E_SLOGRA, newEnt);
        newEnt->posX.i.hi = 0x280 - g_Tilemap.scrollX.i.hi;
        newEnt->posY.i.hi = 0x1A0 - g_Tilemap.scrollY.i.hi;
        newEnt = &g_Entities[88];
        CreateEntityFromCurrentEntity(E_GAIBON, newEnt);
        newEnt->posX.i.hi = 0x2A0 - g_Tilemap.scrollX.i.hi;
        newEnt->posY.i.hi = 0x160 - g_Tilemap.scrollY.i.hi;
        // fall through
    case 1: // Detect whether player is in the room. If so, close the door.
        xPos = PLAYER.posX.i.hi + g_Tilemap.scrollX.i.hi;
        if (24 < xPos && xPos < 968) {
            g_BossFlag |= BOSS_FLAG_DOORS_CLOSED;
            // Unknown sound
            g_api.PlaySfx(0x90);
            D_80097928 = 0;
            self->step++;
        }
        break;
    case 2: // Door is now closed. Wait for player to get far enough to start
            // the fight.
        xPos = PLAYER.posX.i.hi + g_Tilemap.scrollX.i.hi;
        if (0x220 < xPos && xPos < 0x340) {
            g_BossFlag |= BOSS_FLAG_FIGHT_BEGIN;
        }
        if (g_BossFlag & BOSS_FLAG_FIGHT_BEGIN) {
            g_api.TimeAttackController(
                TIMEATTACK_EVENT_SLOGRA_GAIBON_DEFEAT, TIMEATTACK_SET_VISITED);
            D_80097928 = 1;
            D_80097910 = MU_FESTIVAL_OF_SERVANTS;
            self->step++;
        }
        break;
    case 3: // Fight is now active.
        if (g_api.func_80131F68() == false) {
            D_80097928 = 0;
            g_api.PlaySfx(D_80097910);
            self->step++;
        }
        /* fallthrough */
    case 4:
        // Wait for the fight to be over.
        if ((g_BossFlag & BOSS_FLAG_GAIBON_DEAD) &&
            (g_BossFlag & BOSS_FLAG_SLOGRA_DEAD)) {
            g_api.TimeAttackController(
                TIMEATTACK_EVENT_SLOGRA_GAIBON_DEFEAT, TIMEATTACK_SET_RECORD);
            if (g_api.func_80131F68() != false) {
                g_api.PlaySfx(SET_UNK_90);
            }
            D_80097910 = MU_DANCE_OF_GOLD;
            self->step++;
        }
        return;
    case 5: // Fight is now over.
        xPos = 0x80;
        newEntY = 0x180 - g_Tilemap.scrollY.i.hi;
        newEnt = AllocEntity(&g_Entities[160], &g_Entities[192]);
        if (newEnt == NULL) {
            return;
        }
        CreateEntityFromEntity(E_LIFE_UP_SPAWN, self, newEnt);
        newEnt->posX.i.hi = xPos;
        newEnt->posY.i.hi = newEntY;
        newEnt->params = 5;
        g_BossFlag |= BOSS_FLAG_DOORS_OPEN; // Reopen the door
        g_CastleFlags[SG_KILL_ALCH] = 1;
        D_80097928 = 1;
        D_80097910 = MU_DANCE_OF_GOLD;
        self->step++;
        return;
    case 6:
        if (g_api.func_80131F68() == false) {
            D_80097928 = 0;
            g_api.PlaySfx(D_80097910);
            self->step++;
            return;
        }
        break;
    case 0xFF: // Unreachable debug state
        FntPrint("charal %x\n", self->animCurFrame);
        if (g_pads[1].pressed & PAD_SQUARE) {
            if (self->params) {
                return;
            }
            self->animCurFrame++;
            self->params |= 1;
        } else {
            self->params = 0;
        }
        if (g_pads[1].pressed & PAD_CIRCLE) {
            if (!self->step_s) {
                self->animCurFrame--;
                self->step_s |= 1;
                return;
            }
        } else {
            self->step_s = 0;
        }
        break;
    }
}

// blocks that move to close slogra/gaibon room
void EntityBossRoomBlock(Entity* self) {
    switch (self->step) {
    case 0:
        InitializeEntity(g_EInitBossDoor);
        self->animCurFrame = 8;

    case 1:
        if (g_BossFlag & 1) {
            self->ext.GS_Props.timer = 16;
            self->step++;
        }
        break;

    case 2:
        if (self->params == 0) {
            self->velocityX = FIX(1);
        } else {
            self->velocityX = FIX(-1);
        }
        MoveEntity();
        GetPlayerCollisionWith(self, 8, 8, 5);
        if (!(g_Timer & 3)) {
            g_api.PlaySfx(SFX_STONE_MOVE_B);
        }
        if (--self->ext.GS_Props.timer) {
            break;
        }
        self->step++;
        break;

    case 3:
        GetPlayerCollisionWith(self, 8, 8, 5);
        if (g_BossFlag & BOSS_FLAG_DOORS_OPEN) {
            self->step++;
        }
        break;

    case 4:
        self->flags |= FLAG_DESTROY_IF_OUT_OF_CAMERA;
        if (self->params != 0) {
            self->velocityX = FIX(1);
        } else {
            self->velocityX = FIX(-1);
        }
        MoveEntity();
        break;
    }
}
